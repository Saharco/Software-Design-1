# CourseApp: Assignment 1

## Authors
* Sahar Cohen, 206824088
* Yuval Nahon, 206866832

### Previous assignment
This assignment uses the code from the submission by: 206824088-206866832

## Notes

### Implementation Summary

#### Database Abstraction
Serves to simulate a convenient file system hierarchy. Split into 5 main interfaces:

* **DatabaseFactory**: opens new / existing databases.
* **Database**: akin to a *file system*: references its root. Used solely for navigating to nested collections.
* **CollectionReference**: akin to a *folder* in a file system. Used solely for holding documents.
* **DocumentReference**: akin to a *file* in a file system. Values are set in a key-value fashion. Terminal operations include: write/read/update/delete etc.
* **ExtendableDocumentReference**: a DocumentReference that can contain its own collections.

**Example use:**

```kotlin
// Factory pattern for opening databases
val db = CourseAppDatabaseFactory( /* injected SecureStorageFactory */ ).open("cool database")

// Fluent API for interactions with the database.
// Overloaded versions of methods to provide comfortable use in many common cases
db.collection("users")
  .document("sahar")
  .set(Pair("lastname", "cohen"))
  .set("email accounts", listOf("example@gmail.com", "undergrad@campus.technion.ac.il"))
  .write()

val lastnameResult = db.collection("users")
                  .document("sahar")
                  .read("lastname") // = "cohen"
                  
// Many more methods!
```

#### CourseApp Database Managers
The database is utilized by the following classes for managing database operations within the app:
* **AuthenticationManager**: provides the required operations on users in the app.
* **ChannelsManager**: provides the required operations on channels in the app.


#### Data Strcutures
* **Lists**: the database can store entire lists under a single field. (De)serialization with JSON.
* **AVL Tree**: ```//TODO: add this```

### Technical Details
* Tokens are generated by chaining the username with the current time (in miliseconds).
* Document names are encrypted with the SHA-256 one-way encryption algorithm.
* Deletions in the database are *logical* deletions. So, when a document / document's field is deleted, a byte array block of "0" is chained to it. Likewise, an "activated" segment is prefixed by a byte array block of "1". The database abstraction preserves this invariant.
* The database managers access hard-coded collections in a database by default, though another set of collections to operate on can be specified.
* Managers store metadata under the "metadata" collection. 

Short summary of your implementation, including data structures used, design choices made, and
a short tour of the class hierarchy you created.

### Testing Summary
Short summary describing the ways you chose to test your code.

### Difficulties
Please list any technological difficulties you had while working on this assignment, especially
with the tools used: Kotlin, JUnit, MockK, Gradle, and Guice.

### Feedback
Put any feedback you may have for this assignment here. This **will** be read by the course staff,
and may influence future assignments!
