# CourseApp: Assignment 1

## Authors
* Sahar Cohen, 206824088
* Yuval Nahon, 206866832

### Previous assignment
This assignment uses the code from the submission by: 206824088-206866832

## Notes

### Implementation Summary

#### Database Abstraction
Serves to simulate a convenient file system hierarchy. Split into 5 main interfaces:

* **DatabaseFactory**: opens new / existing databases.
* **Database**: akin to a *file system*: references its root. Used solely for navigating to nested collections.
* **CollectionReference**: akin to a *folder* in a file system. Used solely for holding documents.
* **DocumentReference**: akin to a *file* in a file system. Values are set in a key-value fashion. Terminal operations include: write/read/update/delete etc.
* **ExtendableDocumentReference**: a DocumentReference that can contain its own collections.

**Example use:**

```kotlin
// Factory pattern for opening databases
val db = CourseAppDatabaseFactory( /* injected SecureStorageFactory */ ).open("cool database")

// Fluent API for interactions with the database.
// Overloaded versions of methods to provide comfortable use in many common cases
db.collection("users")
  .document("sahar")
  .set(Pair("lastname", "cohen"))
  .set("email accounts", listOf("example@gmail.com", "undergrad@campus.technion.ac.il"))
  .write()

val lastnameResult = db.collection("users")
                  .document("sahar")
                  .read("lastname") // = "cohen"
                  
// Many more methods!
```

#### CourseApp Database Managers
The database is utilized by the following classes for managing database operations within the app:
* **AuthenticationManager**: provides the required operations on users in the app.
* **ChannelsManager**: provides the required operations on channels in the app.

#### Data Strcutures
* **Lists**: the database can store entire lists under a single field. (De)serialization with JSON.
* **AVL Tree**: ```//TODO: add this```

#### Technical Details
* Tokens are generated by chaining the username with the current time (in miliseconds).
* Document names are encrypted with the SHA-256 one-way encryption algorithm.
* Deletions in the database are *logical* deletions. So, when a document / document's field is deleted, a byte array block of "0" is chained to it. Likewise, an "activated" segment is prefixed by a byte array block of "1". The database abstraction preserves this invariant.
* The database managers access hard-coded collections in a database by default, though another set of collections to operate on can be specified.
* Managers store metadata under the "metadata" collection (online users, total users, etc).

### Testing Summary
The following components were thoroughly tested:
* **Database**: tested in CourseAppDatabaseTest. All five components that make up the complete implementation of the database are tested together here. The components work together and you can't do anything useful without all of them at once, hence they're tested together.
* **CourseApp**: tested in CourseAppTest. All the manager classes that make up the complete functionality of the CourseApp are tested together here. The managers are tested together with CourseApp here for the same reason above.
* **CourseAppStatistics**: tested in CourseAppStatisticsTest. 
* **AVLTree**: tested in AVLTreeTest.

In total, there are ```//TODO: x amount``` tests in the project, spanning nearly 100% code coverage.

The tests run on JUnit 5.5 & Guice 1.9 and use the SecureStorageFactoryMock and SecureStorageMock classes to mock the missing behavior of the remote storage. GUice is used to provide the constructor parameter (database mapper) for CourseApp and CourseAppInitializer, and bind the interfaces to the implementations we wrote.

### Difficulties

#### HW 0
We had no prior experience with programming in Kotlin & using MockK so we were pretty clueless at the start. Fortunately, they proved to be very easy and intuitive to use. Our main problem was trying to figure out the database's design. At first, we went with a short and easy API that "did the job", but it felt very "C-style" and low-level (who wants to use enums??), so we scrapped it. Our initial design was prefix-based. When moving on to a better API - we faced the problem of reserved special character "/" in specifying file paths. We decided to used encryption as stated above in order to solve this issue, and made sure to test that it worked. Along the way we got to learn more about Kotlin's standard library.

#### HW 1
We feel like we got the hang of Kotlin quite fast from the previous assignment, but implementing the tree and utilizing it proved to be our biggest challenge in this assignment. We faced our first obstacle when trying to fit the previous assignment's code to work with the new skeleton: this refactoring process took many hours (configuring Guice, creating factory for database instances & mocks, general refactoring).
It took us quite a while to realize that JSON is a helpful tool for our implementation, and we utilized it to add support for storing lists inside the database. From there, the implementation of CourseApp was quite straight-forward, thanks to proper planning (until we got to the tree part...).

### Feedback
Put any feedback you may have for this assignment here. This **will** be read by the course staff,
and may influence future assignments!
